{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "contracts/AudienceManager.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity >=0.8.0 <0.9.0;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/**\n * @title 观众管理合约\n * @dev 管理特定比赛的观众席位、入座以及观众为特定选手的加油热力值。\n * 座位ID从1开始，0代表未占座。\n */\ncontract AudienceManager is Ownable {\n\n    // --- 常量 ---\n    uint256 public constant TOTAL_SEATS = 50; // 每场比赛的座位总数\n    uint256 internal constant NO_SEAT = 0;    // 0 代表用户未选择任何座位 (座位ID从1开始)\n\n    // --- 数据结构 ---\n\n    // 映射1: seatOccupants[比赛ID][内部座位索引 (0 to TOTAL_SEATS-1)] => 占用者地址\n    mapping(uint256 => mapping(uint256 => address)) public seatOccupants;\n\n    // 映射2: userCurrentSeat[比赛ID][用户地址] => 用户占用的座位ID (1-indexed, 或 NO_SEAT(0))\n    mapping(uint256 => mapping(address => uint256)) public userCurrentSeat;\n\n    // 映射3: fighterAudienceHeat[比赛ID][选手地址][观众地址] => 观众为该选手贡献的热力值\n    mapping(uint256 => mapping(address => mapping(address => uint256))) public fighterAudienceHeat;\n\n    // 映射4: activeFightersInMatch[比赛ID] => [选手A地址, 选手B地址]\n    // 用于验证加油目标是否为当前比赛的合法选手。由Owner或MatchContract设置。\n    mapping(uint256 => address[2]) public activeFightersInMatch;\n\n    // --- 事件 ---\n    event SeatTaken(uint256 indexed matchId, uint256 indexed seatId, address indexed user, uint256 timestamp);\n    event SeatLeft(uint256 indexed matchId, uint256 indexed seatId, address indexed user, uint256 timestamp);\n    event ActiveFightersSet(uint256 indexed matchId, address player1, address player2, uint256 timestamp);\n    event FighterCheered(\n        uint256 indexed matchId,\n        address indexed fighterCheeredFor,\n        address indexed audienceMember,\n        uint256 newTotalHeatForThisPairing, // 该观众为该选手贡献的总热力\n        uint256 cheerAmount,                // 本次加油点数\n        uint256 timestamp\n    );\n\n    // --- 构造函数 ---\n    constructor(address _initialOwner) Ownable(_initialOwner) {}\n\n    // --- Owner专属函数 ---\n    /**\n     * @dev 设置某场比赛的活跃对战选手。应在比赛正式开始前由管理员或主比赛合约调用。\n     * @param _matchId 比赛ID。\n     * @param _player1 选手1的地址。\n     * @param _player2 选手2的地址。\n     */\n    function setActiveFighters(uint256 _matchId, address _player1, address _player2) external onlyOwner {\n        require(_matchId > 0, \"AudienceManager: Invalid matchId\");\n        require(_player1 != address(0) && _player2 != address(0), \"AudienceManager: Player address cannot be empty\");\n        require(_player1 != _player2, \"AudienceManager: Two player addresses cannot be the same\");\n\n        activeFightersInMatch[_matchId] = [_player1, _player2];\n        emit ActiveFightersSet(_matchId, _player1, _player2, block.timestamp);\n    }\n\n\n    // --- 修改状态的函数 ---\n\n    /**\n     * @dev 用户为指定比赛选择并占据一个座位。\n     * @param _matchId 要加入的比赛ID。\n     * @param _seatIdFromFrontend 要选择的座位ID (1 到 TOTAL_SEATS)。\n     */\n    function takeSeat(uint256 _matchId, uint256 _seatIdFromFrontend) external {\n        address _user = msg.sender;\n        require(_matchId > 0, \"AudienceManager: Invalid matchId\");\n        require(_seatIdFromFrontend > 0 && _seatIdFromFrontend <= TOTAL_SEATS, \"AudienceManager: Invalid seatId\");\n        require(userCurrentSeat[_matchId][_user] == NO_SEAT, \"AudienceManager: You have already taken a seat\");\n\n        uint256 internalSeatIndex = _seatIdFromFrontend - 1;\n        require(seatOccupants[_matchId][internalSeatIndex] == address(0), \"AudienceManager: This seat is already occupied\");\n\n        seatOccupants[_matchId][internalSeatIndex] = _user;\n        userCurrentSeat[_matchId][_user] = _seatIdFromFrontend;\n\n        emit SeatTaken(_matchId, _seatIdFromFrontend, _user, block.timestamp);\n    }\n\n    /**\n     * @dev 用户离开当前在指定比赛中占据的座位。\n     * @param _matchId 比赛ID。\n     */\n    function leaveSeat(uint256 _matchId) external {\n        address _user = msg.sender;\n        require(_matchId > 0, \"AudienceManager: Invalid matchId\");\n        uint256 currentSeatIdFromFrontend = userCurrentSeat[_matchId][_user];\n        require(currentSeatIdFromFrontend != NO_SEAT, \"AudienceManager: You are not in a seat\");\n        \n        uint256 internalSeatIndex = currentSeatIdFromFrontend - 1;\n        require(seatOccupants[_matchId][internalSeatIndex] == _user, \"AudienceManager: You are not the occupant of this seat\");\n\n        seatOccupants[_matchId][internalSeatIndex] = address(0);\n        userCurrentSeat[_matchId][_user] = NO_SEAT;\n\n        emit SeatLeft(_matchId, currentSeatIdFromFrontend, _user, block.timestamp);\n    }\n\n    /**\n     * @dev 观众为指定比赛中的指定选手加油，增加该选手获得的热力值。\n     * @param _matchId 比赛ID。\n     * @param _fighterToCheerFor 要为其加油的选手地址。\n     * @param _cheerPoints 本次加油增加的热力点数。\n     */\n    function cheerForFighter(uint256 _matchId, address _fighterToCheerFor, uint256 _cheerPoints) external {\n        address _audienceMember = msg.sender;\n        require(_matchId > 0, \"AudienceManager: Invalid matchId\");\n        require(_cheerPoints > 0, \"AudienceManager: Cheer points must be greater than 0\");\n        require(userCurrentSeat[_matchId][_audienceMember] != NO_SEAT, \"AudienceManager: You need to take a seat first\");\n\n        // 验证加油目标是否为本场比赛的合法选手\n        address[2] memory currentFighters = activeFightersInMatch[_matchId];\n        require(currentFighters[0] != address(0) && currentFighters[1] != address(0), \"AudienceManager: The fighters for this match have not been set\");\n        require(\n            _fighterToCheerFor == currentFighters[0] || _fighterToCheerFor == currentFighters[1],\n            \"AudienceManager: The target for cheering is not a valid fighter for this match\"\n        );\n\n        uint256 currentHeat = fighterAudienceHeat[_matchId][_fighterToCheerFor][_audienceMember];\n        uint256 newHeat = currentHeat + _cheerPoints;\n\n        fighterAudienceHeat[_matchId][_fighterToCheerFor][_audienceMember] = newHeat;\n\n        emit FighterCheered(_matchId, _fighterToCheerFor, _audienceMember, newHeat, _cheerPoints, block.timestamp);\n    }\n\n    // --- 只读 (View) 函数 ---\n\n    /**\n     * @dev 获取指定座位上的占用者地址。\n     * @param _matchId 比赛ID。\n     * @param _seatIdFromFrontend 要检查的座位ID (1 到 TOTAL_SEATS)。\n     * @return 占用者地址。\n     */\n    function getSeatOccupant(uint256 _matchId, uint256 _seatIdFromFrontend) external view returns (address) {\n        require(_seatIdFromFrontend > 0 && _seatIdFromFrontend <= TOTAL_SEATS, \"AudienceManager: Invalid seatId\");\n        return seatOccupants[_matchId][_seatIdFromFrontend - 1];\n    }\n\n    /**\n     * @dev 获取指定用户在指定比赛中的座位ID。\n     * @param _matchId 比赛ID。\n     * @param _user 用户地址。\n     * @return 用户占用的座位ID (1-indexed, 或 NO_SEAT(0))。\n     */\n    function getUserSeatId(uint256 _matchId, address _user) external view returns (uint256) {\n        return userCurrentSeat[_matchId][_user];\n    }\n\n    /**\n     * @dev 获取指定观众为指定比赛中的指定选手贡献的总热力值。\n     * @param _matchId 比赛ID。\n     * @param _fighter 选手地址。\n     * @param _audienceMember 观众地址。\n     * @return uint256 热力值。\n     */\n    function getAudienceHeatForFighter(uint256 _matchId, address _fighter, address _audienceMember) external view returns (uint256) {\n        return fighterAudienceHeat[_matchId][_fighter][_audienceMember];\n    }\n\n    /**\n     * @dev 获取指定比赛ID的两位活跃选手地址。\n     * @param _matchId 比赛ID。\n     * @return address[2] memory 包含两位选手地址的数组; 如果未设置则地址为 address(0)。\n     */\n    function getActiveFighters(uint256 _matchId) external view returns (address[2] memory) {\n        return activeFightersInMatch[_matchId];\n    }\n    \n    /**\n     * @dev 获取指定比赛ID的已占用座位信息。\n     * @param _matchId 比赛ID。\n     * @return seatIds_ 已占用座位的ID数组 (1-indexed)。\n     * @return occupants_ 已占用座位的占用者地址数组。\n     */\n    function getOccupiedSeatInfo(uint256 _matchId) external view returns (uint256[] memory seatIds_, address[] memory occupants_) {\n        uint256 occupiedCount = 0;\n        for (uint256 i = 0; i < TOTAL_SEATS; i++) {\n            if (seatOccupants[_matchId][i] != address(0)) {\n                occupiedCount++;\n            }\n        }\n        if (occupiedCount == 0) {\n            return (new uint256[](0), new address[](0));\n        }\n        seatIds_ = new uint256[](occupiedCount);\n        occupants_ = new address[](occupiedCount);\n        uint256 currentIndex = 0;\n        for (uint256 i = 0; i < TOTAL_SEATS; i++) {\n            if (seatOccupants[_matchId][i] != address(0)) {\n                seatIds_[currentIndex] = i + 1; \n                occupants_[currentIndex] = seatOccupants[_matchId][i];\n                currentIndex++;\n                if (currentIndex == occupiedCount) {\n                    break;\n                }\n            }\n        }\n        return (seatIds_, occupants_);\n    }\n}\n"
    },
    "contracts/MatchContract.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0 <0.9.0;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\n// 可选：导入其他合约的接口\n// import \"./IImmortalBlock.sol\"; // 假设你为 ImmortalBlock 创建了接口\n// import \"./IAudienceManager.sol\"; // 假设你为 AudienceManager 创建了接口\n\ncontract MatchContract is Ownable {\n    // --- 常量 ---\n    uint8 public constant TOTAL_QUESTIONS = 10; // 每场比赛的总题目数量\n    uint256 public constant ANSWER_TIMEOUT_DURATION = 60 seconds; // 每题回答时限（例如60秒）\n    uint8 public constant MAX_CONSECUTIVE_WRONG_ANSWERS_FOR_REPLACEMENT = 3; // 触发替换的连续答错次数\n\n    // --- 依赖合约地址 ---\n    address public immortalBlockContractAddress;\n    address public audienceManagerContractAddress;\n    address public refereeAddress; // “AI裁判”或有权提交比赛结果的管理员地址\n\n    // --- 数据结构 ---\n    struct PlayerMatchState {\n        address playerAddress;\n        uint256 score;\n        uint8 consecutiveWrongAnswers;\n        bool isActive; // 标记选手是否仍在场上\n    }\n\n    enum MatchStatus {\n        NotStarted, // 比赛尚未创建或初始化 (默认状态)\n        AwaitingFirstQuestion, // 选手已确定，等待第一题开始 (可选状态)\n        InProgress, // 比赛进行中，选手正在答题\n        PlayerAReplaceable, // A选手达到可被替换条件\n        PlayerBReplaceable, // B选手达到可被替换条件\n        Concluded // 比赛已结束\n    }\n\n    struct Match {\n        uint256 matchId;\n        PlayerMatchState playerA;\n        PlayerMatchState playerB;\n        uint8 currentQuestionIndex;\n        address currentPlayerTurn;\n        uint256 currentQuestionDeadline;\n        MatchStatus status;\n        address winner;\n    }\n\n    mapping(uint256 => Match) public matches;\n\n    // --- 事件 ---\n    event MatchStarted(\n        uint256 indexed matchId,\n        address indexed playerA,\n        address indexed playerB,\n        address firstPlayerTurn, // 谁先手\n        uint256 startTime,\n        uint256 firstQuestionDeadline\n    );\n    // ... (其他事件保持不变)\n    event AnswerResultSubmitted(\n        uint256 indexed matchId,\n        uint256 indexed questionIndex,\n        address indexed player,\n        bool isCorrect,\n        uint256 newScorePlayerA,\n        uint256 newScorePlayerB\n    );\n    event PlayerTurnAdvanced(\n        uint256 indexed matchId,\n        uint256 nextQuestionIndex,\n        address nextPlayerTurn,\n        uint256 newDeadline\n    );\n    event PlayerBecameReplaceable(uint256 indexed matchId, address indexed playerAddress, uint8 consecutiveWrong);\n    event PlayerReplaced(uint256 indexed matchId, address indexed oldPlayer, address indexed newPlayer);\n    event MatchConcluded(\n        uint256 indexed matchId,\n        address indexed winner,\n        uint256 finalScorePlayerA,\n        uint256 finalScorePlayerB\n    );\n\n    // --- 构造函数 ---\n    constructor(\n        address _initialOwner,\n        address _immortalBlockAddr,\n        address _audienceManagerAddr,\n        address _refereeAddr\n    ) Ownable(_initialOwner) {\n        require(_immortalBlockAddr != address(0), \"MatchContract: Invalid immortal block contract address\");\n        require(_audienceManagerAddr != address(0), \"MatchContract: Invalid audience manager contract address\");\n        require(_refereeAddr != address(0), \"MatchContract: Invalid referee address\");\n\n        immortalBlockContractAddress = _immortalBlockAddr;\n        audienceManagerContractAddress = _audienceManagerAddr;\n        refereeAddress = _refereeAddr;\n    }\n\n    // --- 修饰符 ---\n    modifier onlyReferee() {\n        require(msg.sender == refereeAddress, \"MatchContract: Caller is not the authorized referee\");\n        _;\n    }\n\n    // --- Owner专属函数 (用于设置和更新关键地址) ---\n    function setImmortalBlockContract(address _newAddress) external onlyOwner {\n        require(_newAddress != address(0), \"MatchContract: Invalid immortal block contract address\");\n        immortalBlockContractAddress = _newAddress;\n    }\n\n    function setAudienceManagerContract(address _newAddress) external onlyOwner {\n        require(_newAddress != address(0), \"MatchContract: Invalid audience manager contract address\");\n        audienceManagerContractAddress = _newAddress;\n    }\n\n    function setRefereeAddress(address _newAddress) external onlyOwner {\n        require(_newAddress != address(0), \"MatchContract: Invalid referee address\");\n        refereeAddress = _newAddress;\n    }\n\n    // --- 核心功能函数 ---\n\n    /**\n     * @dev 由管理员调用，用于初始化并开始一场新的比赛。\n     * @param _matchId 比赛ID，应与 MatchRegistry 中生成的一致。\n     * @param _playerA 选手A的地址。\n     * @param _playerB 选手B的地址。\n     */\n    function startMatch(uint256 _matchId, address _playerA, address _playerB) external onlyOwner {\n        // 权限：只有合约拥有者（管理员）可以开始比赛\n        // 检查1：输入参数有效性\n        require(_matchId > 0, \"MatchContract: MatchId must be greater than 0\");\n        require(_playerA != address(0) && _playerB != address(0), \"MatchContract: Player address cannot be empty\");\n        require(_playerA != _playerB, \"MatchContract: Two player addresses cannot be the same\");\n\n        // 检查2：确保该 matchId 的比赛尚未开始或不存在\n        // Match 结构体的默认状态 status 会是 0 (即 NotStarted)\n        // 同时检查 playerA 地址是否为0，也能判断是否已被初始化\n        Match storage existingMatch = matches[_matchId];\n        require(\n            existingMatch.playerA.playerAddress == address(0) && existingMatch.status == MatchStatus.NotStarted,\n            \"MatchContract: The matchId already exists or has started\"\n        );\n\n        // 初始化比赛数据\n        Match storage newMatch = matches[_matchId]; // 获取存储指针\n        newMatch.matchId = _matchId;\n\n        newMatch.playerA.playerAddress = _playerA;\n        newMatch.playerA.score = 0;\n        newMatch.playerA.consecutiveWrongAnswers = 0;\n        newMatch.playerA.isActive = true;\n\n        newMatch.playerB.playerAddress = _playerB;\n        newMatch.playerB.score = 0;\n        newMatch.playerB.consecutiveWrongAnswers = 0;\n        newMatch.playerB.isActive = true;\n\n        newMatch.currentQuestionIndex = 0; // 从第0题开始 (代表第一题)\n        newMatch.currentPlayerTurn = _playerA; // V1版本，默认选手A先手\n        newMatch.currentQuestionDeadline = block.timestamp + ANSWER_TIMEOUT_DURATION; // 设置第一题的回答截止时间\n\n        newMatch.status = MatchStatus.InProgress; // 将比赛状态设置为进行中\n        newMatch.winner = address(0); // 初始化胜利者为空地址\n\n        // 关于通知 AudienceManager 合约当前活跃选手：\n        // 如前所述，V1简化版中，此操作将由管理员在调用 startMatch 后，\n        // 再另行调用 AudienceManager 合约的 setActiveFighters 函数来完成。\n        // 若要在此合约内直接调用，需要 AudienceManager 提供相应权限或接口。\n        // 例如:\n        // IAudienceManager(audienceManagerContractAddress).setActiveFighters(_matchId, _playerA, _playerB);\n        // 但这要求 AudienceManager 的 setActiveFighters 允许本合约调用。\n\n        // 触发比赛开始事件\n        emit MatchStarted(\n            _matchId,\n            _playerA,\n            _playerB,\n            newMatch.currentPlayerTurn, // 明确谁先手\n            block.timestamp, // 比赛正式开始的时间戳\n            newMatch.currentQuestionDeadline\n        );\n    }\n\n    // --- 内部函数 ---\n/**\n * @dev 内部函数，用于结束比赛，判定胜者，并记录到不朽链。\n * @param _matchId 要结束的比赛ID。\n */\nfunction _concludeMatch(uint256 _matchId) internal {\n    Match storage concludedMatch = matches[_matchId];\n\n    // 防止重复结束\n    require(concludedMatch.status != MatchStatus.Concluded, \"MatchContract: Match already concluded\");\n\n    address winningPlayer;\n    if (concludedMatch.playerA.score > concludedMatch.playerB.score) {\n        winningPlayer = concludedMatch.playerA.playerAddress;\n    } else if (concludedMatch.playerB.score > concludedMatch.playerA.score) {\n        winningPlayer = concludedMatch.playerB.playerAddress;\n    } else {\n        winningPlayer = address(0); // 平局\n    }\n\n    concludedMatch.winner = winningPlayer;\n    concludedMatch.status = MatchStatus.Concluded;\n\n    emit MatchConcluded(\n        _matchId,\n        winningPlayer,\n        concludedMatch.playerA.score,\n        concludedMatch.playerB.score\n    );\n\n    // 调用不朽链合约记录结果\n    // 假设 ImmortalBlock.sol 有一个函数 forgeBlock(uint256 matchId, address winner, uint256 scoreA, uint256 scoreB)\n    // 并且本合约地址被授权调用它（例如 ImmortalBlock 也 Ownable，且 owner 是同一个人，或者 ImmortalBlock 有授权机制）\n    // 为了V1简化，我们假设 ImmortalBlock 的 forgeBlock 可以被任何人调用，或者是由本合约 Owner 后期手动整理数据调用。\n    // 如果要直接调用，需要定义接口 IImmortalBlock\n    // IImmortalBlock(immortalBlockContractAddress).forgeBlock(_matchId, winningPlayer, ...);\n    // 为简单起见，V1版本中，MatchContract仅发出事件，实际写入ImmortalBlock可由管理员根据事件链下触发，\n    // 或者我们假设有一个简单的 forgeBlock 接口。\n    // 我们先专注于 MatchContract 的逻辑。与 ImmortalBlock 的交互可以后续细化。\n    // 例如，可以简单地尝试调用，如果失败，事件仍然发出，数据仍在 MatchContract 中。\n\n    // 示例：尝试调用一个简化的 ImmortalBlock 函数\n    // function recordVictory(uint256 _mId, address _winAddr) external;\n    // (bool success, ) = immortalBlockContractAddress.call(\n    //     abi.encodeWithSignature(\"recordVictory(uint256,address)\", _matchId, winningPlayer)\n    // );\n    // if (!success) {\n    //     // 可选：发出一个调用失败的事件或日志\n    //     console.log(\"Failed to record victory on ImmortalBlock for match %s\", _matchId);\n    // }\n}\n\n/**\n     * @dev 由裁判调用，提交选手对当前问题的回答结果。\n     * 即使选手进入可替换状态，比赛也会继续进行。\n     * @param _matchId 比赛ID。\n     * @param _playerWhoAnswered 回答问题的选手地址。\n     * @param _questionIndex 回答的问题索引。\n     * @param _isCorrect 回答是否正确。\n     */\n    function submitAnswerResult(\n        uint256 _matchId,\n        address _playerWhoAnswered,\n        uint256 _questionIndex,\n        bool _isCorrect\n    ) external onlyReferee { // 只有裁判可以调用\n        Match storage currentMatch = matches[_matchId];\n\n        // --- 验证阶段 ---\n        require(currentMatch.matchId == _matchId, \"MatchContract: Match not initialized or ID mismatch.\");\n        // 比赛状态可以是 InProgress, PlayerAReplaceable, 或 PlayerBReplaceable，都允许提交答案\n        require(\n            currentMatch.status == MatchStatus.InProgress ||\n            currentMatch.status == MatchStatus.PlayerAReplaceable ||\n            currentMatch.status == MatchStatus.PlayerBReplaceable,\n            \"MatchContract: Match is not in a playable state.\" // 英文提示：比赛未处于可进行状态\n        );\n        require(_questionIndex == currentMatch.currentQuestionIndex, \"MatchContract: Submitted result is for an outdated or future question index.\");\n        require(_playerWhoAnswered == currentMatch.currentPlayerTurn, \"MatchContract: It's not this player's turn to answer.\");\n\n        // --- 获取选手状态存储指针 ---\n        PlayerMatchState storage answeringPlayerState;\n        PlayerMatchState storage opponentPlayerState;\n\n        if (_playerWhoAnswered == currentMatch.playerA.playerAddress) {\n            answeringPlayerState = currentMatch.playerA;\n            opponentPlayerState = currentMatch.playerB;\n        } else if (_playerWhoAnswered == currentMatch.playerB.playerAddress) {\n            answeringPlayerState = currentMatch.playerB;\n            opponentPlayerState = currentMatch.playerA;\n        } else {\n            revert(\"MatchContract: Player who answered is not part of this match.\");\n        }\n\n        // --- 更新选手答题状态 ---\n        if (_isCorrect) {\n            answeringPlayerState.score++;\n            answeringPlayerState.consecutiveWrongAnswers = 0;\n            // 如果选手之前处于可替换状态，但现在答对了，可以将比赛状态恢复为 InProgress\n            // （前提是对手也不是可替换状态）\n            if (currentMatch.status == MatchStatus.PlayerAReplaceable && _playerWhoAnswered == currentMatch.playerA.playerAddress ||\n                currentMatch.status == MatchStatus.PlayerBReplaceable && _playerWhoAnswered == currentMatch.playerB.playerAddress) {\n                 // 检查对手状态，只有当对手也不是Replaceable时才恢复为InProgress\n                bool opponentIsReplaceable = (_playerWhoAnswered == currentMatch.playerA.playerAddress && currentMatch.status == MatchStatus.PlayerBReplaceable) ||\n                                             (_playerWhoAnswered == currentMatch.playerB.playerAddress && currentMatch.status == MatchStatus.PlayerAReplaceable);\n                if (!opponentIsReplaceable) {\n                    currentMatch.status = MatchStatus.InProgress;\n                }\n            }\n\n        } else { // 回答错误\n            answeringPlayerState.consecutiveWrongAnswers++;\n            if (answeringPlayerState.consecutiveWrongAnswers >= MAX_CONSECUTIVE_WRONG_ANSWERS_FOR_REPLACEMENT) {\n                // 即使状态已经是 PlayerAReplaceable/PlayerBReplaceable，再次触发事件也无妨，表明又错了一次\n                if (_playerWhoAnswered == currentMatch.playerA.playerAddress) {\n                    currentMatch.status = MatchStatus.PlayerAReplaceable;\n                } else {\n                    currentMatch.status = MatchStatus.PlayerBReplaceable;\n                }\n                emit PlayerBecameReplaceable(_matchId, _playerWhoAnswered, answeringPlayerState.consecutiveWrongAnswers);\n            }\n        }\n\n        // --- 触发答案提交事件 ---\n        uint256 scoreA_afterUpdate = currentMatch.playerA.score;\n        uint256 scoreB_afterUpdate = currentMatch.playerB.score;\n\n        emit AnswerResultSubmitted(\n            _matchId,\n            _questionIndex,\n            _playerWhoAnswered,\n            _isCorrect,\n            scoreA_afterUpdate,\n            scoreB_afterUpdate\n        );\n\n        // --- 推进比赛状态到下一题/下一位选手 (不再有提前 return 的暂停逻辑) ---\n        currentMatch.currentQuestionIndex++;\n\n        if (currentMatch.currentQuestionIndex >= TOTAL_QUESTIONS) {\n            _concludeMatch(_matchId); // 调用内部函数结束比赛\n            return; // 比赛结束\n        }\n\n        // 切换到另一位选手答题\n        if (currentMatch.currentPlayerTurn == currentMatch.playerA.playerAddress) {\n            currentMatch.currentPlayerTurn = currentMatch.playerB.playerAddress;\n        } else {\n            currentMatch.currentPlayerTurn = currentMatch.playerA.playerAddress;\n        }\n\n        // 为新题目和新选手设置回答截止时间\n        currentMatch.currentQuestionDeadline = block.timestamp + ANSWER_TIMEOUT_DURATION;\n\n        emit PlayerTurnAdvanced(\n            _matchId,\n            currentMatch.currentQuestionIndex,\n            currentMatch.currentPlayerTurn,\n            currentMatch.currentQuestionDeadline\n        );\n    }\n    /**\n     * @dev 由管理员调用，用一名新选手替换场上当前处于可替换状态的选手。\n     * 新选手将继承被替换选手的得分，但连续答错次数重置为0。\n     * 比赛状态将恢复为 InProgress。\n     * @param _matchId 比赛ID。\n     * @param _playerToReplace 将被替换的场上选手的地址。\n     * @param _newPlayer 将上场替换的新选手的地址（原观众）。\n     */\n    function replacePlayer(\n        uint256 _matchId,\n        address _playerToReplace,\n        address _newPlayer\n    ) external onlyOwner { // 只有合约拥有者（管理员）可以执行此操作\n        Match storage currentMatch = matches[_matchId];\n\n        // --- 验证阶段 ---\n        require(currentMatch.matchId == _matchId, \"MatchContract: Match not initialized or ID mismatch.\"); // 英文提示\n        require(\n            currentMatch.status == MatchStatus.PlayerAReplaceable || currentMatch.status == MatchStatus.PlayerBReplaceable,\n            \"MatchContract: Match is not in a state where a player can be replaced.\" // 英文提示\n        );\n        require(_playerToReplace != address(0) && _newPlayer != address(0), \"MatchContract: Player addresses cannot be zero.\"); // 英文提示\n        require(_playerToReplace != _newPlayer, \"MatchContract: New player cannot be the same as the one being replaced.\"); // 英文提示\n\n        PlayerMatchState storage playerStateToUpdate;\n        address opponentAddress;\n\n        // 确认 _playerToReplace 是哪位选手，并获取其状态存储指针\n        if (currentMatch.status == MatchStatus.PlayerAReplaceable) {\n            require(_playerToReplace == currentMatch.playerA.playerAddress, \"MatchContract: Player to replace does not match replaceable status (expected Player A).\"); // 英文提示\n            playerStateToUpdate = currentMatch.playerA;\n            opponentAddress = currentMatch.playerB.playerAddress;\n        } else { // currentMatch.status == MatchStatus.PlayerBReplaceable\n            require(_playerToReplace == currentMatch.playerB.playerAddress, \"MatchContract: Player to replace does not match replaceable status (expected Player B).\"); // 英文提示\n            playerStateToUpdate = currentMatch.playerB;\n            opponentAddress = currentMatch.playerA.playerAddress;\n        }\n        \n        // 确保新选手不是场上的另一位对手\n        require(_newPlayer != opponentAddress, \"MatchContract: New player is already the opponent.\"); // 英文提示\n\n        // --- 执行替换 ---\n\n        // 1. 标记旧选手不再活跃\n        playerStateToUpdate.isActive = false; \n        // 旧选手的得分和最终的连续答错次数保留在 playerStateToUpdate 中，作为历史记录。\n        // 但由于 playerStateToUpdate 是一个 storage pointer，接下来我们会覆盖它的内容。\n        // 如果需要保留旧选手的完整最终状态，需要先复制一份或有单独的存储。\n        // V1简化：直接更新此槽位为新选手。\n\n        // 2. 更新槽位为新选手的信息\n        // （新选手继承得分，连续答错清零）\n        if (_playerToReplace == currentMatch.playerA.playerAddress) {\n            currentMatch.playerA = PlayerMatchState({\n                playerAddress: _newPlayer,\n                score: playerStateToUpdate.score, // 继承得分\n                consecutiveWrongAnswers: 0,       // 重置连续答错\n                isActive: true\n            });\n        } else {\n            currentMatch.playerB = PlayerMatchState({\n                playerAddress: _newPlayer,\n                score: playerStateToUpdate.score, // 继承得分\n                consecutiveWrongAnswers: 0,       // 重置连续答错\n                isActive: true\n            });\n        }\n\n        // 3. 更新比赛状态\n        currentMatch.status = MatchStatus.InProgress;\n\n        // 4. 处理当前回合和截止时间\n        // 新选手上场，当前题目继续，但重置回答截止时间。\n        // 回合归属：如果被替换的是当前答题者，则新选手接替回合；否则回合不变。\n        if (currentMatch.currentPlayerTurn == _playerToReplace) {\n            currentMatch.currentPlayerTurn = _newPlayer;\n        }\n        // 无论谁的回合，都重置当前问题的截止时间，给新局面一些准备\n        currentMatch.currentQuestionDeadline = block.timestamp + ANSWER_TIMEOUT_DURATION;\n\n        // 触发选手被替换事件\n        emit PlayerReplaced(_matchId, _playerToReplace, _newPlayer);\n\n        // 触发回合信息更新事件 (因为截止时间已变，当前答题人也可能已变)\n        emit PlayerTurnAdvanced(\n            _matchId,\n            currentMatch.currentQuestionIndex, // 题目索引不变\n            currentMatch.currentPlayerTurn,\n            currentMatch.currentQuestionDeadline\n        );\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}